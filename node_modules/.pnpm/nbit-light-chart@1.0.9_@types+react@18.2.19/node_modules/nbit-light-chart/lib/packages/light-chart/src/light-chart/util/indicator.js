'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dayjs = require('dayjs');
var kLine = require('../components/k-line/k-line.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var dayjs__default = /*#__PURE__*/_interopDefaultLegacy(dayjs);

/**
 * 计算 SMA
 */
const calculateSMA = (data, count, price) => {
    let result = [];
    let avg = data => {
        let sum = 0;
        for (let i = 0; i < data.length; i += 1) {
            sum += data[i][price];
        }
        return sum / data.length;
    };
    for (let i = count - 1, len = data.length; i < len; i += 1) {
        let val = avg(data.slice(i - count + 1, i + 1));
        if (i - count + 1 === 0) {
            for (let j = 0; j < count; j += 1) {
                result.push({ time: data[j].time, value: val });
            }
        }
        else {
            result.push({ time: data[i].time, value: val });
        }
    }
    return result;
};
/**
 * 计算EMA
 * // ema 上一日
 * // price 价格,dif
 * // period 日期
 */
const calculateEMA = (ema, price, period) => {
    return (2 * price + (period - 1) * ema) / (period + 1);
};
/**
 * 计算 MACD
 * fast 快线
 * slow 慢线
 * signal 日期
 */
const calculateMACD = (data, fast, slow, signal) => {
    const newData = [];
    data.forEach((item, index) => {
        let emaFast = 0;
        let emaSlow = 0;
        let dea = 0;
        let dif = 0;
        if (index < fast - 1) {
            emaFast = 0;
        }
        else {
            emaFast = calculateEMA(newData[index - 1]?.emaFast || 0, item.close, fast);
        }
        if (index < slow - 1) {
            emaSlow = 0;
        }
        else {
            emaSlow = calculateEMA(newData[index - 1]?.emaSlow || 0, item.close, slow);
        }
        dif = emaFast - emaSlow;
        if (index < signal - 1) {
            dea = 0;
        }
        else {
            dea = calculateEMA(newData[index - 1]?.dea || 0, dif, signal);
        }
        newData.push({
            emaFast,
            emaSlow,
            dif,
            dea,
            value: (dif - dea) * 2,
            time: item.time,
        });
    });
    return newData;
};
const updateTimeOfData = (value, type, kLineChartData) => {
    const timeList = kLineChartData.map((item, index) => {
        return {
            index,
            time: dayjs__default["default"](item.time).format('YYYY-MM-DD HH:mm'),
        };
    });
    const newData = [];
    if (type === kLine.TimeSharingType.Min) {
        let i = 0;
        while (i < timeList.length) {
            const min = Number(timeList[i].time.split(' ')[1].split(':')[1]);
            if (min === 0 || min % value === 0) {
                newData.push({
                    ...kLineChartData[i],
                });
                i += 1;
            }
            else {
                const remainder = min % value;
                let tempIndex = remainder;
                const tempObj = {};
                while (tempIndex <= value && i < timeList.length) {
                    if (!tempObj.low) {
                        tempObj.low = kLineChartData[i].low;
                    }
                    else {
                        if (kLineChartData[i].low < tempObj.low) {
                            tempObj.low = kLineChartData[i].low;
                        }
                    }
                    if (!tempObj.high) {
                        tempObj.high = kLineChartData[i].high;
                    }
                    else {
                        if (kLineChartData[i].high > tempObj.high) {
                            tempObj.high = kLineChartData[i].high;
                        }
                    }
                    if (tempIndex === remainder) {
                        tempObj.open = kLineChartData[i].open;
                    }
                    tempObj.close = kLineChartData[i].close;
                    tempIndex += 1;
                    i += 1;
                    if (i === timeList.length) {
                        tempObj.time = kLineChartData[i - 1].time + 1000 * 60 * (value - tempIndex + 1);
                    }
                    else {
                        tempObj.time = kLineChartData[i - 1].time;
                    }
                }
                newData.push({
                    ...tempObj,
                });
            }
        }
    }
    if (type === kLine.TimeSharingType.Hour) {
        let i = 0;
        while (i < timeList.length) {
            const hour = Number(timeList[i].time.split(' ')[1].split(':')[0]);
            const min = Number(timeList[i].time.split(' ')[1].split(':')[1]);
            if (min === 0 && hour % value === 0) {
                newData.push({
                    ...kLineChartData[i],
                });
                i += 1;
            }
            else {
                const remainder = hour % value;
                let tempIndex = remainder * 60 + min;
                const _tempIndex = tempIndex;
                const tempObj = {};
                while (tempIndex <= value * 60 && i < timeList.length) {
                    if (!tempObj.low) {
                        tempObj.low = kLineChartData[i].low;
                    }
                    else {
                        if (kLineChartData[i].low < tempObj.low) {
                            tempObj.low = kLineChartData[i].low;
                        }
                    }
                    if (!tempObj.high) {
                        tempObj.high = kLineChartData[i].high;
                    }
                    else {
                        if (kLineChartData[i].high > tempObj.high) {
                            tempObj.high = kLineChartData[i].high;
                        }
                    }
                    if (tempIndex === _tempIndex) {
                        tempObj.open = kLineChartData[i].open;
                    }
                    tempObj.close = kLineChartData[i].close;
                    tempIndex += 1;
                    i += 1;
                    if (i === timeList.length) {
                        tempObj.time = kLineChartData[i - 1].time + 1000 * 60 * (value * 60 - tempIndex + 1);
                    }
                    else {
                        tempObj.time = kLineChartData[i - 1].time;
                    }
                }
                newData.push({
                    ...tempObj,
                });
            }
        }
    }
    if (type === kLine.TimeSharingType.Week) {
        let i = 0;
        while (i < timeList.length) {
            const date = timeList[i].time.split(' ')[0];
            const dayOfWeek = dayjs__default["default"](kLineChartData[i].time).day();
            const _tempIndex = i;
            const newDate = dayOfWeek === 7
                ? timeList[i].time.split(' ')[0]
                : dayjs__default["default"](timeList[i].time.split(' ')[0])
                    .add(7 - dayOfWeek, 'day')
                    .format('YYYY-MM-DD');
            const tempObj = {};
            let tempDate = date;
            while (dayjs__default["default"](tempDate).isBetween(date, newDate, null, '[]') && i < timeList.length) {
                if (!tempObj.low) {
                    tempObj.low = kLineChartData[i].low;
                }
                else {
                    if (kLineChartData[i].low < tempObj.low) {
                        tempObj.low = kLineChartData[i].low;
                    }
                }
                if (!tempObj.high) {
                    tempObj.high = kLineChartData[i].high;
                }
                else {
                    if (kLineChartData[i].high > tempObj.high) {
                        tempObj.high = kLineChartData[i].high;
                    }
                }
                if (_tempIndex === i) {
                    tempObj.open = kLineChartData[i].open;
                }
                tempObj.close = kLineChartData[i].close;
                i += 1;
                tempObj.time = dayjs__default["default"](newDate).valueOf();
                if (i !== timeList.length) {
                    tempDate = timeList[i].time.split(' ')[0];
                }
            }
            newData.push({
                ...tempObj,
            });
        }
    }
    if (type === kLine.TimeSharingType.Mon) {
        let i = 0;
        while (i < timeList.length) {
            const year = Number(timeList[i].time.split(' ')[0].split('-')[0]);
            const mon = Number(timeList[i].time.split(' ')[0].split('-')[1]);
            const remainder = mon % value;
            let tempMon = mon;
            let tempYear = year;
            const _tempIndex = i;
            const tempObj = {};
            while (tempMon === mon && tempYear === year && i < timeList.length) {
                if (!tempObj.low) {
                    tempObj.low = kLineChartData[i].low;
                }
                else {
                    if (kLineChartData[i].low < tempObj.low) {
                        tempObj.low = kLineChartData[i].low;
                    }
                }
                if (!tempObj.high) {
                    tempObj.high = kLineChartData[i].high;
                }
                else {
                    if (kLineChartData[i].high > tempObj.high) {
                        tempObj.high = kLineChartData[i].high;
                    }
                }
                if (_tempIndex === i) {
                    tempObj.open = kLineChartData[i].open;
                }
                tempObj.close = kLineChartData[i].close;
                i += 1;
                if (Number(timeList[i === timeList.length ? i - 1 : i].time.split(' ')[0].split('-')[0]) !== tempYear ||
                    Number(timeList[i === timeList.length ? i - 1 : i].time.split(' ')[0].split('-')[1]) !== tempMon) {
                    tempYear = Number(timeList[i === timeList.length ? i - 1 : i].time.split(' ')[0].split('-')[0]);
                    tempMon = Number(timeList[i === timeList.length ? i - 1 : i].time.split(' ')[0].split('-')[1]);
                }
                if (i === timeList.length) {
                    tempObj.time = dayjs__default["default"](`${tempMon + value - remainder > 12 ? tempYear + 1 : tempYear}-${tempMon + value - remainder > 12 ? tempMon + value - remainder - 12 : tempMon + value - remainder}-1`).valueOf();
                }
                else {
                    tempObj.time = kLineChartData[i - 1].time;
                }
            }
            newData.push({
                ...tempObj,
            });
        }
    }
    return newData;
};

exports.calculateEMA = calculateEMA;
exports.calculateMACD = calculateMACD;
exports.calculateSMA = calculateSMA;
exports.updateTimeOfData = updateTimeOfData;
