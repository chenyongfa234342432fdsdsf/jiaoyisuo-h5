"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importBuildFileName = exports.loadBuild = void 0;
const utils_1 = require("./utils");
const importBuildFileName_1 = require("../shared/importBuildFileName");
Object.defineProperty(exports, "importBuildFileName", { enumerable: true, get: function () { return importBuildFileName_1.importBuildFileName; } });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const import_1 = require("@brillout/import");
async function loadBuild() {
    const importer = require('../autoImporter');
    if (importer.status === 'SET') {
        importer.load();
        return {
            success: true,
            entryFile: await getImporterFilePath()
        };
    }
    else if (importer.status === 'UNSET') {
        // Yarn PnP or disabled
        const { success, distImporterFilePath } = await loadWithNodejs();
        return {
            success,
            entryFile: distImporterFilePath
        };
    }
    else {
        const { status } = importer;
        (0, utils_1.assert)(false, { status });
    }
    async function loadWithNodejs() {
        const root = (0, utils_1.getCwd)();
        if (!root) {
            (0, utils_1.assert)((0, utils_1.isCloudflareWorkersAlike)());
            return {
                success: false,
                distImporterFilePath: null
            };
        }
        // The runtime doesn't have access to config.build.outDir so we try and shoot in the dark
        const distImporterPathRelative = path_1.default.posix.join(root, 'dist', 'server', importBuildFileName_1.importBuildFileName);
        const distImporterDir = path_1.default.posix.dirname(distImporterPathRelative);
        let distImporterPath;
        try {
            distImporterPath = await requireResolve_(distImporterPathRelative);
        }
        catch (err) {
            (0, utils_1.assert)(!fs_1.default.existsSync(distImporterDir), { distImporterDir, distImporterPathRelative });
            return {
                success: false,
                distImporterFilePath: null
            };
        }
        if (isWebpackResolve(distImporterPath)) {
            return {
                success: false,
                distImporterFilePath: null
            };
        }
        (0, utils_1.assert)(distImporterPath.endsWith('.cjs')); // Ensure ESM compability
        await require_(distImporterPath);
        return { success: true, distImporterFilePath: distImporterPath };
    }
    async function getImporterFilePath() {
        let autoImporterFilePath = null;
        try {
            autoImporterFilePath = require.resolve('../autoImporter');
        }
        catch (_a) {
            return null;
        }
        if (isWebpackResolve(autoImporterFilePath)) {
            return null;
        }
        (0, utils_1.assert)((await require_(autoImporterFilePath)) === importer);
        return autoImporterFilePath;
    }
}
exports.loadBuild = loadBuild;
function isWebpackResolve(moduleResolve) {
    return typeof moduleResolve === 'number';
}
// Workaround for webpack static analysis warnings: (Some users use webpack to bundle their VPS app's server code.)
// ```
// Critical dependency: require function is used in a way in which dependencies cannot be statically extracted
// Critical dependency: the request of a dependency is an expression
// ```
// Just `console.log(require)` already triggers the warnings, so the following seems to be the only way (using eval() shows a warning when using esbuild).
async function requireResolve_(id) {
    const req = await getRequire();
    return req.resolve(id);
}
async function require_(id) {
    const req = await getRequire();
    return req(id);
}
var req;
async function getRequire() {
    if (!req) {
        const { createRequire } = (await (0, import_1.import_)('module'));
        req = createRequire(__filename);
    }
    return req;
}
/* Debug:
;(async () => {
  console.log('test webpack static analysis suppression trick')
  console.log(await requireResolve_('path'))
  console.log(await require('path'))
})()
//*/
