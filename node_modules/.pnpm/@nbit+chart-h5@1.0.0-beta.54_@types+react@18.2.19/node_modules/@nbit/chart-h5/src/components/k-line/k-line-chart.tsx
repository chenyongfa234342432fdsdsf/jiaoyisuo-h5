import dayjs from 'dayjs'
import {
  createChart,
  DeepPartial,
  CandlestickStyleOptions,
  LineStyle,
  ISeriesApi,
  LineData,
  CandlestickData,
  HistogramData,
  LineWidth,
  Time,
  BarPrice,
  SeriesMarker,
} from '@nbit/lightweight-charts'
import React, { forwardRef, useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react'
import classNames from 'classnames'
import {
  calculateSMA,
  calculateMACD,
  KLineChartData,
  MainIndicatorType,
  SubIndicatorType,
  ChartLayoutOptionsType,
  SwitchTimeType,
  TimeSharingType,
  ThemeEnum,
  calBoll,
  calRsi,
  calKdj,
  calWr,
  timeLocaleLanguageMap,
  calcChg,
  calcAmp,
  CommonMainOrSubType,
  CreateChartType,
  showFormatTime,
  KLineChartType,
} from '@nbit/chart-utils'
import {
  calHeightAndLowPoint,
  subscribeClickChange,
  calChartIndicatorPositon,
  numFormat,
  SubKType,
  getBuyMarkers,
  tradeDirection,
  calQuickBuyAndSellPoint,
  tradeStatus,
} from './helper'

import './index.css'

/** 三元期权交易方向 */
enum TernaryOptionTradeDirectionEnum {
  /** 买涨 */
  call = 'call',
  /** 买跌 */
  put = 'put',
  /** 涨超 */
  overCall = 'over_call',
  /** 跌超 */
  overPut = 'over_put',
}

/** 三元期权交易结果 */
enum TernaryOptionTradeStatus {
  /** 成功 */
  success = 'success',
  /** 失败 */
  fail = 'fail',
  /** 等待 */
  wait = 'wait',
}

type SN = string | number
interface MainKType {
  time: SN
  open: SN
  high: SN
  low: SN
  close: SN
  isUp: boolean
  chg: SN
  amp: SN
  volume: SN
  quoteVolume: SN
  buy?: SN
  sell?: SN
  overBuy?: SN
  overSell?: SN
  priceSpread?: SN
}

interface PropsType {
  data: Array<KLineChartData>
  mainIndicator: MainIndicatorType
  subIndicator: SubIndicatorType
  createChart: CreateChartType & { cardBgColor03: string }
  chartLayoutOptions: ChartLayoutOptionsType
  curTime: SwitchTimeType
  theme: string
  chartHeight: number
  locale: string
  offset: {
    priceOffset: number
    amountOffset: number
  }
  coinInfo: {
    baseSymbolName: string
    quoteSymbolName: string
  }
  getDataAndUpdateChart: number
  getMoreKlineData: (v) => void
  updateMarketChangesTime: (v) => void
  colors: number
  curDataRef: any
  ordersData?: any
  from?: KLineChartType
  optionIcon?: any
  optionBuyCallback?: any
  optionSellCallback?: any
  optionActiveTab?: any
  countDownComponent?: any
  tradeRestSecond?: any
  optionAnimation?: any
}

type IChartApi = ReturnType<typeof createChart>

/** 涨跌色 */
export enum UserUpsAndDownsColorEnum {
  greenUpRedDown = 1, // 绿涨红跌
  redUpGreenDown = 2, // 红涨绿跌
}

function KLineChart(props: PropsType, ref) {
  const {
    mainIndicator,
    subIndicator,
    chartHeight,
    offset,
    updateMarketChangesTime,
    colors,
    coinInfo,
    getMoreKlineData,
    ordersData,
    from,
    optionBuyCallback,
    optionSellCallback,
    optionIcon,
    optionActiveTab,
    countDownComponent,
    tradeRestSecond,
    optionAnimation,
  } = props

  const { priceOffset, amountOffset } = offset
  const chartRef = useRef<IChartApi>()
  const candlestickSeriesRef = useRef<ISeriesApi<'Candlestick'>>()
  const macdVolumeSeriesRef = useRef<ISeriesApi<'Histogram'>>()
  const smaLineRef = useRef<Array<ISeriesApi<'Line'>>>()
  const timeLineRef = useRef<ISeriesApi<'Line'>>()
  const buyMarkersRef = useRef<any>()
  const ordersDataRef = useRef<any>()
  ordersDataRef.current = ordersData

  const bollRef = useRef<{
    mid: ISeriesApi<'Line'>
    upper: ISeriesApi<'Line'>
    lower: ISeriesApi<'Line'>
  }>()

  const kdjRef = useRef<{
    k: ISeriesApi<'Line'>
    d: ISeriesApi<'Line'>
    j: ISeriesApi<'Line'>
  }>()

  const chartPriceLineProperty = {
    crosshairMarkerVisible: false,
    baseLineVisible: false,
    priceLineVisible: false,
    lastValueVisible: false,
    lineType: 2,
  }

  /** 是否点击图表 */
  const isHoverChart = useRef<boolean>(false)

  const [curMaxAndMinPoint, setCurMaxAndMinPoint] = useState({
    min: {
      time: 0,
      value: 0,
      x: 0,
      y: 0,
    },
    max: {
      time: 0,
      value: 0,
      x: 0,
      y: 0,
    },
  })

  const [curBuyAndSellPoint, setCurBuyAndSellPoint] = useState({
    min: {
      time: 0,
      value: 0,
      x: 0,
      y: 0,
    },
    max: {
      time: 0,
      value: 0,
      x: 0,
      y: 0,
    },
  })
  const [tradeStatusOverList, setTradeStatusOverList] = useState<any>([])
  const [chartCrossHair, setChartCrossHair] = useState<{
    x: number
    y: number
    show: boolean
  }>({
    x: 0,
    y: 0,
    show: false,
  })
  const [heightChange, setHeightChange] = useState<number>(0)
  const rsiRef = useRef<Array<ISeriesApi<'Line'>>>()

  const wrRef = useRef<Array<ISeriesApi<'Line'>>>()

  const deaRef = useRef<ISeriesApi<'Line'>>()
  const difRef = useRef<ISeriesApi<'Line'>>()
  const containerRef = useRef<HTMLDivElement | null>(null)

  const volumeSeriesRef = useRef<ISeriesApi<'Histogram'>>()

  const checkIsUp = (value): boolean => {
    return value?.close > value?.open
  }

  const [maIndicator, setMaIndicator] = useState<Array<number>>()
  const [visibleTimeRange, setVisibleTimeRange] = useState({
    from: 0,
    to: 0,
  })
  const [mainK, setMainK] = useState<MainKType>()

  const [subK, setSubK] = useState<SubKType>()

  const [bollK, setBollK] = useState<{
    mid: number
    upper: number
    lower: number
  }>({
    mid: 0,
    upper: 0,
    lower: 0,
  })

  const [volume, setVolume] = useState<{
    vol: number
    quoteVolume: number
    dir: string
  }>({
    vol: 0,
    quoteVolume: 0,
    dir: 'rise',
  })

  const [kdjK, setKdjK] = useState<{
    k: number
    d: number
    j: number
  }>()

  const [rsiK, setRsiK] = useState<{
    r: number
    s: number
    i: number
  }>()
  const mainIndicatorRef = useRef<MainIndicatorType>()
  const subIndicatorRef = useRef<SubIndicatorType>()
  const [wrK, setWrK] = useState<Array<number>>()
  const propsDataRef = useRef<Array<KLineChartData>>(props.data)
  const curTimeRef = useRef<SwitchTimeType>(props.curTime)
  const colorsRef = useRef<number>(UserUpsAndDownsColorEnum.greenUpRedDown)

  // const timeCount = useRef<number>(0)
  useEffect(() => {
    // propsDataRef.current = props.data
    curTimeRef.current = props.curTime
    mainIndicatorRef.current = props.mainIndicator
    subIndicatorRef.current = props.subIndicator
    colorsRef.current = colors
  }, [props.data, props.curTime, props.mainIndicator, props.subIndicator, colors])
  // propsDataRef.current = props.curDataRef || []

  /** 指标在图表中的位置计算 */
  const { chartScaleMargins, volScaleMargins, macdScaleMargins, kdjScaleMargins, rsiScaleMargins, wrScaleMargins } =
    calChartIndicatorPositon(subIndicator)

  const gridColor = props.theme === ThemeEnum.light ? 'rgba(0,0,0,0.02)' : 'rgba(255,255,255,0.02)'
  useEffect(() => {
    if (chartRef.current) {
      chartRef.current.applyOptions({
        timeScale: {
          barSpacing: 5,
          minBarSpacing: 5,
          lockVisibleTimeRangeOnResize: true,
          tickMarkFormatter: item => {
            return showFormatTime(item, props.curTime.unit)
          },
        },
      })
    }
  }, [props.curTime.unit, props.curTime.value])

  const chartPropertySetting = {
    layout: props.chartLayoutOptions,
    localization: {
      timeFormatter: item => {
        return dayjs(item).format('YY/MM/DD HH:mm')
      },
    },
    timeScale: {
      barSpacing: 5,
      minBarSpacing: 5,
      borderColor: gridColor,
      lockVisibleTimeRangeOnResize: true,
      tickMarkFormatter: item => {
        return showFormatTime(item, props.curTime.unit)
      },
    },
    rightPriceScale: {
      scaleMargins: chartScaleMargins,
      entireTextOnly: true,
      visible: true,
      alignLabels: true,
      autoScale: true,
      borderColor: gridColor,
    },
  }

  useEffect(() => {
    /** 平滑效果 */
    /** 考虑了3个可能性，切换tab时，改变屏幕大小时，滚动时都会对可见区域处理，这块极其容易出bug */
    requestAnimationFrame(() => {
      calHeightAndLowPoint(
        visibleTimeRange,
        curTimeRef,
        propsDataRef,
        timeLineRef,
        candlestickSeriesRef,
        chartRef,
        setCurMaxAndMinPoint,
        props.createChart,
        priceOffset
      )
    })

    calQuickBuyAndSellPoint(
      visibleTimeRange,
      curTimeRef,
      propsDataRef,
      timeLineRef,
      candlestickSeriesRef,
      chartRef,
      setCurBuyAndSellPoint,
      props.createChart,
      priceOffset
    )
    // setTimeout(() => {
    //   calHeightAndLowPoint(
    //     visibleTimeRange,
    //     curTimeRef,
    //     propsDataRef,
    //     timeLineRef,
    //     candlestickSeriesRef,
    //     chartRef,
    //     setCurMaxAndMinPoint
    //   )
    // })
  }, [visibleTimeRange, subIndicator])

  useEffect(() => {
    chartRef.current = createChart(document.getElementById('chart') as HTMLElement, chartPropertySetting)

    chartRef.current.applyOptions({
      handleScale: {
        axisPressedMouseMove: {
          time: true,
          price: false,
        },
        mouseWheel: false,
        pinch: true,
      },
    })
    const subscribeTimeChange = newVisibleTimeRange => {
      if (chartRef.current?.timeScale().getVisibleRange()?.from) {
        setVisibleTimeRange(chartRef.current?.timeScale().getVisibleRange() as any)
      }

      // setPopVisible(false)
    }
    /** 最高价最低价逻辑 */
    chartRef.current.timeScale().subscribeVisibleTimeRangeChange(subscribeTimeChange)

    chartRef.current.timeScale().fitContent()

    const subscribeMoveChange = param => {
      if (
        !param.time ||
        param.point.x < 0 ||
        param.point.x > (containerRef?.current?.clientWidth || 0) ||
        param.point.y < 0 ||
        param.point.y > (containerRef?.current?.clientHeight || 0)
      ) {
        setChartCrossHair({
          x: 0,
          y: 0,
          show: false,
        })
        isHoverChart.current = false
        return
      }
      isHoverChart.current = true
      const time = param.time

      const volumeSeriesData = macdVolumeSeriesRef.current
        ? param.seriesData.get(macdVolumeSeriesRef.current as ISeriesApi<'Histogram'>)
        : undefined
      let chartData = candlestickSeriesRef.current
        ? param.seriesData.get(candlestickSeriesRef.current as ISeriesApi<'Candlestick'>)
        : {}

      const smaLineArr: Array<number> = []
      smaLineRef.current?.forEach(item => {
        smaLineArr.push(param.seriesData.get(item as ISeriesApi<'Line'>)?.value)
      })

      const dif = difRef.current ? param.seriesData.get(difRef.current as ISeriesApi<'Line'>) : undefined
      const dea = deaRef.current ? param.seriesData.get(deaRef.current as ISeriesApi<'Line'>) : undefined

      setMaIndicator(smaLineArr)

      if (!chartData) {
        chartData = propsDataRef.current.filter(item => {
          return item.time === time
        })?.[0] as unknown as BarPrice
      }
      const _chartData = propsDataRef.current.filter(item => {
        return item.time === time
      })?.[0]

      const buyAmount = ordersDataRef.current?.filter(item => {
        return item.ts.toString() === time.toString()
      })
      const tempObj: any = {}

      buyAmount?.forEach(item => {
        if (!tempObj[`${item.sideInd}`]) {
          tempObj[`${item.sideInd}`] = {
            ...item,
          }
        } else {
          tempObj[`${item.sideInd}`] = {
            ...tempObj[`${item.sideInd}`],
            amount: Number(item.amount) + Number(tempObj[`${item.sideInd}`].amount),
          }
        }
      })
      setMainK({
        time: dayjs(time as number).format('YYYY-MM-DD HH:mm'),
        open: chartData?.open,
        close: chartData?.close,
        high: chartData?.high,
        low: chartData?.low,
        isUp: checkIsUp(chartData),
        chg: calcChg(chartData, priceOffset),
        amp: calcAmp(chartData, priceOffset),
        volume: (_chartData as MainKType)?.volume,
        quoteVolume: (_chartData as MainKType)?.quoteVolume,
        buy: tempObj[tradeDirection.call]?.amount
          ? `${tempObj[tradeDirection.call]?.amount} ${tempObj[tradeDirection.call]?.currency}`
          : '',
        sell: tempObj[tradeDirection.put]?.amount
          ? `${tempObj[tradeDirection.put]?.amount} ${tempObj[tradeDirection.put]?.currency}`
          : '',
        overBuy: tempObj[tradeDirection.overCall]?.amount
          ? `${tempObj[tradeDirection.overCall]?.amount} ${tempObj[tradeDirection.overCall]?.currency}`
          : '',
        overSell: tempObj[tradeDirection.overPut]?.amount
          ? `${tempObj[tradeDirection.overPut]?.amount} ${tempObj[tradeDirection.overPut]?.currency}`
          : '',
        priceSpread: tempObj[tradeDirection.overCall]?.amplitude || tempObj[tradeDirection.overPut]?.amplitude,
      })
      setSubK({
        macd: volumeSeriesData?.value,
        dea: dea?.value,
        dif: dif?.value,
      })

      setBollK({
        mid: param.seriesData.get(bollRef.current?.mid as ISeriesApi<'Line'>)?.value,
        upper: param.seriesData.get(bollRef.current?.upper as ISeriesApi<'Line'>)?.value,
        lower: param.seriesData.get(bollRef.current?.lower as ISeriesApi<'Line'>)?.value,
      })

      setKdjK({
        k: param.seriesData.get(kdjRef.current?.k as ISeriesApi<'Line'>)?.value,
        d: param.seriesData.get(kdjRef.current?.d as ISeriesApi<'Line'>)?.value,
        j: param.seriesData.get(kdjRef.current?.j as ISeriesApi<'Line'>)?.value,
      })

      setRsiK({
        r: param.seriesData.get(rsiRef.current?.[0] as ISeriesApi<'Line'>)?.value,
        s: param.seriesData.get(rsiRef.current?.[1] as ISeriesApi<'Line'>)?.value,
        i: param.seriesData.get(rsiRef.current?.[2] as ISeriesApi<'Line'>)?.value,
      })

      const wrLineArr: Array<number> = []
      wrRef.current?.forEach(item => {
        wrLineArr.push(param.seriesData.get(item as ISeriesApi<'Line'>)?.value)
      })

      setWrK(wrLineArr)

      let toolTipWidth = 170
      let toolTipHeight = 172
      let toolTipMargin = 15

      let y = param.point.y

      let left = param.point.x + toolTipMargin
      if (left > (containerRef?.current?.clientWidth || 0) - toolTipWidth) {
        // left = param.point.x - toolTipMargin - toolTipWidth

        setChartCrossHair({
          x: 16,
          y: from === KLineChartType.Ternary ? 0 : 32,
          show: true,
        })
      } else {
        setChartCrossHair({
          x: (containerRef?.current?.clientWidth || 0) - toolTipWidth - 16,
          y: from === KLineChartType.Ternary ? 0 : 32,
          show: true,
        })
      }

      // let top = y + toolTipMargin
      // if (top > (containerRef?.current?.clientHeight || 0) - toolTipHeight) {
      //   top = y - toolTipHeight - toolTipMargin
      // }

      // setChartCrossHair({
      //   x: left,
      //   y: top,
      //   show: true,
      // })
    }

    chartRef.current.subscribeCrosshairMove(subscribeMoveChange)

    /** 订阅图表滚动事件 */

    let timer
    function onVisibleLogicalRangeChanged(newVisibleLogicalRange) {
      timer = setTimeout(() => {
        let logicalRange = chartRef.current?.timeScale()?.getVisibleLogicalRange()

        if (logicalRange !== null) {
          const curRef =
            curTimeRef.current.unit === 'time' || curTimeRef.current.unit === 's'
              ? timeLineRef.current
              : candlestickSeriesRef.current
          const barsInfo: any = curRef?.barsInLogicalRange(logicalRange as any)
          if (barsInfo !== null && barsInfo?.barsBefore < 10) {
            getMoreKlineData({ time: propsDataRef.current?.[0]?.time })
            clearTimeout(timer)
          }
        }
      }, 500)
    }

    chartRef.current.timeScale().subscribeVisibleLogicalRangeChange(onVisibleLogicalRangeChanged)

    return () => {
      chartRef.current?.timeScale().unsubscribeVisibleTimeRangeChange(subscribeTimeChange)
      // chartRef.current?.unsubscribeClick(param => {
      //   subscribeClickChange(param, markersRef, setPopVisible, props, priceOffset, setCurMarkers)
      // })
      chartRef.current?.unsubscribeCrosshairMove(subscribeMoveChange)
      chartRef.current?.timeScale().unsubscribeVisibleLogicalRangeChange(onVisibleLogicalRangeChanged)
    }
  }, [])

  const getColorOfSetting = (close, open) => {
    if (colorsRef.current === UserUpsAndDownsColorEnum.greenUpRedDown) {
      return close > open ? 'rgba(80, 177, 108, 0.5)' : 'rgba(233, 90, 92, 0.5)'
    } else {
      return close > open ? 'rgba(233, 90, 92, 0.5)' : 'rgba(80, 177, 108, 0.5)'
    }
  }

  useImperativeHandle(ref, () => ({
    scrollToTime(marketChangesTime) {
      /** 跳转行情异动的 k 线柱子 */
      if (chartRef.current && propsDataRef.current?.length) {
        /** 库api 有bug,无法获取正确的位置，导致 scrollToPosition不可用 */
        const timeToCoordinate = chartRef.current?.timeScale().timeToCoordinate(marketChangesTime as Time)
        // console.log('getVisibleLogicalRange--------', chartRef.current?.timeScale().getVisibleLogicalRange())
        //   chartRef.current?.timeScale().scrollToPosition(timeToCoordinate as number, true)

        setTimeout(() => {
          chartRef.current?.timeScale().setVisibleRange({
            from: (curTimeRef.current.unit === 'm'
              ? marketChangesTime - 1000 * 60 * 120
              : marketChangesTime - 1000 * 60 * 60 * 120) as Time,
            to: curTimeRef.current.unit === 'm' ? marketChangesTime + 1000 * 60 : marketChangesTime + 1000 * 60 * 60,
          })
        })

        /** 跳转之后清空时间 */
        updateMarketChangesTime(0)
      }
    },
    updateCandlestickData(data, curRefData) {
      propsDataRef.current = curRefData || []

      candlestickSeriesRef.current?.update(data as CandlestickData)
      if (!isHoverChart.current) {
        setMainK({
          ...data,
          time: dayjs(data.time).format('YYYY/MM/DD HH:mm'),
          isUp: checkIsUp(data),
          chg: calcChg(data, priceOffset),
          amp: calcAmp(data, priceOffset),
        })
      }
      if (chartRef.current?.timeScale().getVisibleRange()?.from) {
        setVisibleTimeRange(chartRef.current?.timeScale().getVisibleRange() as any)
      }
    },
    updateTimeData(data, curRefData) {
      propsDataRef.current = curRefData || []
      timeLineRef.current?.update(data)
      if (!isHoverChart.current) {
        setMainK({
          ...data,
          time: dayjs(data.time).format('YYYY/MM/DD HH:mm'),
          isUp: checkIsUp(data),
          chg: calcChg(data, priceOffset),
          amp: calcAmp(data, priceOffset),
        })
      }
      if (chartRef.current?.timeScale().getVisibleRange()?.from) {
        setVisibleTimeRange(chartRef.current?.timeScale().getVisibleRange() as any)
      }
    },
    updateVolumeData(data) {
      if (subIndicatorRef.current?.vol?.select) {
        volumeSeriesRef.current?.update({
          ...data,
          // 'rgba(var(--buy_up_color), 0.5)' : 'rgba(var(--sell_down_color), 0.5)'
          color: getColorOfSetting(data.close, data.open),
        })
        if (!isHoverChart.current) {
          setVolume({
            ...data,
            vol: data.value,
          })
        }
      }
    },
    updateMaData() {
      if (mainIndicatorRef.current?.ma.select) {
        let _ma: Array<number> = []
        mainIndicatorRef.current?.ma.cur.forEach((item, index) => {
          if (item.select) {
            const { strip, type } = item

            let smaData = calculateSMA(propsDataRef.current, Number(strip), type, priceOffset)

            _ma.push(smaData[smaData.length - 1]?.value)
            smaData[smaData.length - 1]?.time &&
              smaLineRef.current?.[index]?.update(smaData[smaData.length - 1] as LineData)
          }
        })
        if (!isHoverChart.current) {
          setMaIndicator(_ma)
        }
      }
    },
    updateMacdData(data) {
      if (subIndicatorRef.current?.macd.select) {
        let _subK: SubKType = {
          dea: undefined,
          dif: undefined,
          macd: undefined,
        }
        const fast = subIndicatorRef.current?.macd.cur.fast as CommonMainOrSubType
        const slow = subIndicatorRef.current?.macd.cur.slow as CommonMainOrSubType
        const signal = subIndicatorRef.current?.macd.cur.signal as CommonMainOrSubType
        const newData = calculateMACD(propsDataRef.current, Number(fast), Number(slow), Number(signal), priceOffset)

        _subK.dif = newData[newData.length - 1]?.dif
        _subK.dea = newData[newData.length - 1]?.dea
        _subK.macd = newData[newData.length - 1]?.value

        const difData =
          newData.map(item => {
            return {
              time: item.time,
              value: item.dif,
            }
          }) || []

        const deaData =
          newData.map(item => {
            return {
              time: item.time,
              value: item.dea,
            }
          }) || []

        const macdData =
          newData.map(item => {
            return {
              time: item?.time,
              value: item?.value,
              // color: item?.value < 0 ? props.createChart.downColor : props.createChart.upColor,
              color: getColorOfSetting(item?.value, 0),
            }
          }) || []
        const nameList = [difRef.current, deaRef.current, macdVolumeSeriesRef.current]
        const dataList = [difData[difData.length - 1], deaData[deaData.length - 1], macdData[macdData.length - 1]]
        subIndicator.macd.curLine?.forEach((item, index) => {
          if (item.select) {
            nameList[index]?.update(dataList[index] as LineData)
          }
        })
        if (!isHoverChart.current) {
          setSubK(_subK)
        }
      }
    },
    updateBollData() {
      if (mainIndicatorRef.current?.boll.select) {
        let _boll: {
          mid: number
          upper: number
          lower: number
        } = {
          mid: 0,
          upper: 0,
          lower: 0,
        }
        const result = calBoll(
          propsDataRef.current,
          [
            Number(mainIndicatorRef.current?.boll.cur.mid as CommonMainOrSubType),
            Number(mainIndicatorRef.current?.boll.cur.std as CommonMainOrSubType),
          ],
          priceOffset
        )
        const bollList = ['mid', 'upper', 'lower']
        bollList.forEach((item, index) => {
          const _index = Object.keys(_boll)[index]
          _boll[_index] = result[result.length - 1][_index]
          const value =
            result.map(_item => {
              return {
                value: _item[_index],
                time: _item.time,
              }
            }) || []
          bollRef.current?.[_index].update(value[value.length - 1] as LineData)
        })
        if (!isHoverChart.current) {
          setBollK(_boll)
        }
      }
    },
    updateKdjData() {
      if (subIndicatorRef.current?.kdj.select) {
        let _kdjK: {
          k: number
          d: number
          j: number
        } = {
          k: 0,
          d: 0,
          j: 0,
        }
        const result = calKdj(
          propsDataRef.current,
          [
            Number(subIndicatorRef.current?.kdj.cur.k as CommonMainOrSubType),
            Number(subIndicatorRef.current?.kdj.cur.d as CommonMainOrSubType),
            Number(subIndicatorRef.current?.kdj.cur.j as CommonMainOrSubType),
          ],
          priceOffset
        )

        const kdjList = ['K', 'D', 'J']
        kdjList.forEach((item, index) => {
          const _index = Object.keys(_kdjK)[index]
          _kdjK[_index] = result[result.length - 1]?.[_index]
          const value =
            result.map(_item => {
              return {
                value: _item[_index],
                time: _item.time,
              }
            }) || []
          kdjRef.current?.[_index].update(value[value.length - 1] as LineData)
        })
        if (!isHoverChart.current) {
          setKdjK(_kdjK)
        }
      }
    },
    updateRsiData() {
      if (subIndicatorRef.current?.rsi.select) {
        let _rsiK: {
          r: number
          s: number
          i: number
        } = {
          r: 0,
          s: 0,
          i: 0,
        }
        const result = calRsi(
          propsDataRef.current,
          [
            Number(subIndicatorRef.current?.rsi.cur[0].value),
            Number(subIndicatorRef.current?.rsi.cur[1].value),
            Number(subIndicatorRef.current?.rsi.cur[2].value),
          ],
          priceOffset
        )
        _rsiK.r = result[result.length - 1]?.r
        _rsiK.s = result[result.length - 1]?.s
        _rsiK.i = result[result.length - 1]?.i

        subIndicatorRef.current?.rsi.cur.forEach((_item, index) => {
          if (_item.select) {
            const value =
              result.map(item => {
                return {
                  value: item[Object.keys(_rsiK)[index]],
                  time: item.time,
                }
              }) || []
            rsiRef.current?.[index]?.update(value[value.length - 1] as LineData)
          }
        })
        if (!isHoverChart.current) {
          setRsiK(_rsiK)
        }
      }
    },
    updateWrData() {
      if (subIndicatorRef.current?.wr.select) {
        let _wrK: Array<number> = []

        subIndicatorRef.current.wr.cur.forEach((_item, index) => {
          if (_item.select) {
            const result = calWr(
              propsDataRef.current,
              [Number(subIndicatorRef.current?.wr.cur[index].value)],
              [
                { key: 'wr1', title: 'wr1' },
                { key: 'wr2', title: 'wr2' },
              ],
              priceOffset
            )
            _wrK.push(result[result.length - 1]?.wr1)
            const value =
              result.map(item => {
                return {
                  value: item.wr1,
                  time: item.time,
                }
              }) || []
            wrRef.current?.[index]?.update(value[value.length - 1] as LineData)
          }
        })
        if (!isHoverChart.current) {
          setWrK(_wrK)
        }
      }
    },
  }))

  useLayoutEffect(() => {
    const handleResize = () => {
      chartRef.current?.applyOptions({
        ...chartPropertySetting,
        width: containerRef.current?.clientWidth,
        height: containerRef.current?.clientHeight,
        rightPriceScale: {
          ...chartPropertySetting.rightPriceScale,
          scaleMargins: chartScaleMargins,
        },
      })

      setHeightChange(new Date().valueOf())
      if (chartRef.current?.timeScale().getVisibleRange()?.from) {
        setVisibleTimeRange(chartRef.current?.timeScale().getVisibleRange() as any)
      }
    }

    window.addEventListener('resize', handleResize)
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }, [])

  useEffect(() => {
    chartRef.current?.applyOptions({
      ...chartPropertySetting,
      height: chartHeight,
      layout: {
        ...props.chartLayoutOptions,
      },
      grid: {
        vertLines: {
          color: gridColor,
        },
        horzLines: {
          color: gridColor,
        },
      },
      rightPriceScale: {
        ...chartPropertySetting.rightPriceScale,
        scaleMargins: chartScaleMargins,
      },
    })
  }, [props.chartLayoutOptions.background, props.chartLayoutOptions.textColor, chartHeight])

  useEffect(() => {
    let _ma: Array<number> = []
    let _mainK: MainKType = {
      ...props.data[props.data.length - 1],
      time: dayjs(props.data[props.data.length - 1]?.time).format('YY-MM-DD HH:mm'),
      isUp: checkIsUp(props.data[props.data.length - 1]),
      chg: calcChg(props.data[props.data.length - 1], priceOffset),
      amp: calcAmp(props.data[props.data.length - 1], priceOffset),
      volume: props.data[props.data.length - 1]?.volume as number,
      quoteVolume: props.data[props.data.length - 1]?.quoteVolume as number,
    }

    let _subK: SubKType = {
      dea: undefined,
      dif: undefined,
      macd: undefined,
    }

    let _boll: {
      mid: number
      upper: number
      lower: number
    } = {
      mid: 0,
      upper: 0,
      lower: 0,
    }

    let _kdjK: {
      k: number
      d: number
      j: number
    } = {
      k: 0,
      d: 0,
      j: 0,
    }

    let _rsiK: {
      r: number
      s: number
      i: number
    } = {
      r: 0,
      s: 0,
      i: 0,
    }

    let _wrK: Array<number> = []

    if (chartRef.current) {
      if (!candlestickSeriesRef.current) {
        candlestickSeriesRef.current = chartRef.current.addCandlestickSeries({
          upColor: props?.createChart?.upColor || '#26a69a', // 涨
          downColor: props?.createChart?.downColor || '#ef5350', // 跌
          borderVisible: false,
          wickUpColor: props?.createChart?.upColor || '#26a69a',
          wickDownColor: props?.createChart?.downColor || '#ef5350',
          ...chartPriceLineProperty,
          lastValueVisible: true,
          priceFormat: {
            minMove: 1 / 10 ** priceOffset,
          },
        } as DeepPartial<CandlestickStyleOptions>)
      }

      /* 清空操作,除了k线都需要清空 * */
      smaLineRef.current?.forEach(item => {
        item.setData([])
      })
      timeLineRef.current?.setData([])

      bollRef.current?.lower.setData([])
      bollRef.current?.mid.setData([])
      bollRef.current?.upper.setData([])
      difRef.current?.setData([])
      deaRef.current?.setData([])
      macdVolumeSeriesRef.current?.setData([])
      kdjRef.current?.k.setData([])
      kdjRef.current?.d.setData([])
      kdjRef.current?.j.setData([])
      rsiRef.current?.forEach(item => {
        item.setData([])
      })
      wrRef.current?.forEach(item => {
        item.setData([])
      })
      buyMarkersRef.current = getBuyMarkers(ordersData, propsDataRef, props.createChart)

      if (props.curTime.unit === 'time' || props.curTime.unit === 's') {
        if (!timeLineRef.current) {
          timeLineRef.current = chartRef.current?.addLineSeries({
            color: props.createChart.brandColor,
            lineWidth: 1,
            lineStyle: LineStyle.Solid,
            ...chartPriceLineProperty,
            lastValueVisible: true,
          }) as ISeriesApi<'Line'>
        }
        timeLineRef.current.setData(
          propsDataRef.current.map(item => {
            return {
              ...item,
              value: item.close,
            }
          }) as unknown as LineData[]
        )
        candlestickSeriesRef.current.setData([])
        const oldData =
          timeLineRef.current?.markers()?.filter(item => {
            return item.id?.toString() === '1' || item.id?.toString() === '2'
          }) || []

        const preData: any =
          timeLineRef.current?.markers()?.filter(item => {
            return item.id?.toString() !== '1' && item.id?.toString() !== '2'
          }) || []

        const newList: any = []
        preData?.forEach(item => {
          buyMarkersRef.current?.forEach(_item => {
            if (
              item.id === _item.id &&
              item.statusCd === tradeStatus.processing &&
              _item.statusCd === tradeStatus.complete
            ) {
              const val = propsDataRef.current?.filter(childItem => {
                return childItem.time === _item.time
              })?.[0]?.close
              if (val) {
                const y = timeLineRef.current?.priceToCoordinate(val)
                const x = chartRef.current?.timeScale().timeToCoordinate(_item.time as Time)
                if (x && y) {
                  newList.push({
                    ..._item,
                    x,
                    y,
                  })
                }
              }
            }
          })
        })
        if (newList?.length) {
          //
          setTradeStatusOverList(
            newList.map(item => {
              return {
                ...item,
                loading: true,
              }
            })
          )
          timeLineRef.current?.setMarkers(
            oldData
              .concat(
                buyMarkersRef.current?.filter(item => {
                  return item.id !== newList[0].id
                }) || []
              )
              ?.sort?.((a, b) => {
                return Number(a.time) - Number(b.time)
              }) as unknown as SeriesMarker<Time>[]
          )
          setTimeout(() => {
            setTradeStatusOverList(newList)
            setTimeout(() => {
              setTradeStatusOverList([])
              timeLineRef.current?.setMarkers(
                oldData.concat(buyMarkersRef.current)?.sort?.((a, b) => {
                  return Number(a.time) - Number(b.time)
                }) as unknown as SeriesMarker<Time>[]
              )
            }, 1000)
          }, 500)
        } else {
          timeLineRef.current.setMarkers(
            oldData.concat(buyMarkersRef.current)?.sort?.((a, b) => {
              return Number(a.time) - Number(b.time)
            }) as unknown as SeriesMarker<Time>[]
          )
        }
      } else {
        candlestickSeriesRef.current.setData(propsDataRef.current as CandlestickData[])
        const oldData =
          candlestickSeriesRef.current?.markers()?.filter(item => {
            return item.id?.toString() === '1' || item.id?.toString() === '2'
          }) || []

        candlestickSeriesRef.current.setMarkers(
          oldData.concat(buyMarkersRef.current)?.sort?.((a, b) => {
            return Number(a.time) - Number(b.time)
          }) as unknown as SeriesMarker<Time>[]
        )
      }

      if (subIndicator.vol?.select) {
        if (!volumeSeriesRef.current) {
          volumeSeriesRef.current = chartRef.current?.addHistogramSeries({
            color: props.createChart.upColor,
            priceFormat: {
              type: 'price',
            },
            priceScaleId: 'vol',
            ...chartPriceLineProperty,
          }) as ISeriesApi<'Histogram'>
        }
        volumeSeriesRef.current.setData(
          propsDataRef.current.map(item => {
            return {
              time: item.time,
              value: item.volume,
              color: getColorOfSetting(item.close, item.open),
            }
          }) as HistogramData[]
        )
      }

      if (mainIndicator.boll.select) {
        if (!bollRef.current) {
          bollRef.current = {
            mid: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[0].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              ...chartPriceLineProperty,
            }),
            upper: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[1].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              ...chartPriceLineProperty,
            }),
            lower: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[2].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              ...chartPriceLineProperty,
            }),
          }
        }
        const result = calBoll(
          props.data,
          [mainIndicator.boll.cur.mid as number, mainIndicator.boll.cur.std as number],
          priceOffset
        )

        _boll.lower = result[result.length - 1]?.lower
        _boll.mid = result[result.length - 1]?.mid
        _boll.upper = result[result.length - 1]?.upper

        bollRef.current.mid.setData(
          result.map(item => {
            return {
              value: item.mid,
              time: item.time,
            }
          }) as LineData[]
        )
        bollRef.current.lower.setData(
          result.map(item => {
            return {
              value: item.lower,
              time: item.time,
            }
          }) as LineData[]
        )
        bollRef.current.upper.setData(
          result.map(item => {
            return {
              value: item.upper,
              time: item.time,
            }
          }) as LineData[]
        )
      }

      if (mainIndicator.ma.select) {
        if (!smaLineRef.current) {
          const smaLineList: Array<ISeriesApi<'Line'>> = []
          mainIndicator.ma.cur.forEach(item => {
            const value = chartRef.current?.addLineSeries({
              color: item.color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              ...chartPriceLineProperty,
            }) as ISeriesApi<'Line'>
            smaLineList.push(value)
          })
          smaLineRef.current = smaLineList
        }
        mainIndicator.ma.cur.forEach((item, index) => {
          if (item.select) {
            const { strip, type } = item

            let smaData = calculateSMA(props.data, Number(strip), type, priceOffset)
            _ma.push(smaData[smaData.length - 1]?.value)
            smaLineRef.current?.[index]?.setData(smaData as LineData[])
          }
        })
      }

      if (subIndicator.macd.select) {
        const { fast, slow, signal } = subIndicator.macd.cur

        const newData = calculateMACD(props.data, Number(fast), Number(slow), Number(signal), priceOffset)

        _subK.dif = newData[newData.length - 1]?.dif
        _subK.dea = newData[newData.length - 1]?.dea
        _subK.macd = newData[newData.length - 1]?.value

        const difData = newData.map(item => {
          return {
            time: item.time,
            value: item.dif,
          }
        })

        const deaData = newData.map(item => {
          return {
            time: item.time,
            value: item.dea,
          }
        })

        const macdData = newData.map(item => {
          return {
            time: item?.time,
            value: item?.value,
            color: item?.value < 0 ? props.createChart.downColor : props.createChart.upColor,
          }
        })

        const subLineConfig = {
          color: props.createChart.brandColor,
          lineWidth: 1 as LineWidth,
          lineStyle: LineStyle.Solid,
          priceScaleId: 'volume',
          scaleMargins: macdScaleMargins,
          ...chartPriceLineProperty,
        }
        if (!difRef.current) {
          difRef.current = chartRef.current?.addLineSeries({
            ...subLineConfig,
            color: '#9660c4',
          }) as ISeriesApi<'Line'>
        }

        if (!deaRef.current) {
          deaRef.current = chartRef.current?.addLineSeries({
            ...subLineConfig,
            color: '#84aad5',
          }) as ISeriesApi<'Line'>
        }

        if (!macdVolumeSeriesRef.current) {
          macdVolumeSeriesRef.current = chartRef.current?.addHistogramSeries({
            color: props.createChart.upColor,
            priceFormat: {
              type: 'price',
            },
            priceScaleId: 'volume',
            ...chartPriceLineProperty,
          }) as ISeriesApi<'Histogram'>
        }

        difRef.current.setData(difData as LineData[])
        deaRef.current.setData(deaData as LineData[])
        macdVolumeSeriesRef.current.setData(macdData as HistogramData[])
      }

      if (subIndicator.kdj.select) {
        if (!kdjRef.current) {
          kdjRef.current = {
            k: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[0].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              priceScaleId: 'kdj',
              ...chartPriceLineProperty,
            }),
            d: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[1].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              priceScaleId: 'kdj',
              ...chartPriceLineProperty,
            }),
            j: chartRef.current?.addLineSeries({
              color: mainIndicator.ma.cur[2].color,
              lineWidth: 1,
              lineStyle: LineStyle.Solid,
              priceScaleId: 'kdj',
              ...chartPriceLineProperty,
            }),
          }
        }
        const result = calKdj(
          props.data,
          [subIndicator.kdj.cur.k as number, subIndicator.kdj.cur.d as number, subIndicator.kdj.cur.j as number],
          priceOffset
        )
        _kdjK.k = result[result.length - 1]?.k
        _kdjK.d = result[result.length - 1]?.d
        _kdjK.j = result[result.length - 1]?.j

        kdjRef.current.k.setData(
          result.map(item => {
            return {
              value: item.k,
              time: item.time,
            }
          }) as LineData[]
        )
        kdjRef.current.d.setData(
          result.map(item => {
            return {
              value: item.d,
              time: item.time,
            }
          }) as LineData[]
        )
        kdjRef.current.j.setData(
          result.map(item => {
            return {
              value: item.j,
              time: item.time,
            }
          }) as LineData[]
        )
      }

      if (subIndicator.rsi.select) {
        if (!rsiRef.current) {
          const rsiList: Array<ISeriesApi<'Line'>> = []
          subIndicator.rsi.cur.forEach(item => {
            rsiList.push(
              chartRef.current?.addLineSeries({
                color: item.color,
                lineWidth: 1,
                lineStyle: LineStyle.Solid,
                priceScaleId: 'rsi',
                ...chartPriceLineProperty,
              }) as ISeriesApi<'Line'>
            )
          })
          rsiRef.current = rsiList
        }
        const result = calRsi(
          props.data,
          [
            Number(subIndicator.rsi.cur[0]?.value),
            Number(subIndicator.rsi.cur[1]?.value),
            Number(subIndicator.rsi.cur[2]?.value),
          ],
          priceOffset
        )
        _rsiK.r = result[result.length - 1]?.r
        _rsiK.s = result[result.length - 1]?.s
        _rsiK.i = result[result.length - 1]?.i

        subIndicator.rsi.cur.forEach((item, index) => {
          rsiRef.current?.[index]?.setData(
            result.map(item => {
              return {
                value: item[Object.keys(_rsiK)[index]],
                time: item.time,
              }
            }) as LineData[]
          )
        })
      }

      if (subIndicator.wr.select) {
        if (!wrRef.current) {
          const wrList: Array<ISeriesApi<'Line'>> = []
          subIndicator.wr.cur.forEach(item => {
            wrList.push(
              chartRef.current?.addLineSeries({
                color: item.color,
                lineWidth: 1,
                lineStyle: LineStyle.Solid,
                priceScaleId: 'wr',
                ...chartPriceLineProperty,
              }) as ISeriesApi<'Line'>
            )
          })
          wrRef.current = wrList
        }
        subIndicator.wr.cur.forEach((item, index) => {
          const result = calWr(
            props.data,
            [Number(subIndicator.wr.cur[index].value)],
            [
              { key: 'wr1', title: 'wr1' },
              { key: 'wr2', title: 'wr2' },
            ],
            priceOffset
          )
          _wrK.push(result[result.length - 1]?.wr1)

          wrRef.current?.[index]?.setData(
            result.map(item => {
              return {
                value: item.wr1,
                time: item.time,
              }
            }) as LineData[]
          )
        })
      }

      setMaIndicator(_ma)
      setMainK(_mainK)
      setSubK(_subK)
      setBollK(_boll)
      setKdjK(_kdjK)
      setRsiK(_rsiK)
      setWrK(_wrK)
    }
  }, [mainIndicator, subIndicator, chartRef.current, props.getDataAndUpdateChart, colors, ordersData])

  useEffect(() => {
    if (candlestickSeriesRef.current) {
      candlestickSeriesRef.current.applyOptions({
        upColor: props?.createChart?.upColor || '#26a69a', // 涨
        downColor: props?.createChart?.downColor || '#ef5350', // 跌
        wickUpColor: props?.createChart?.upColor || '#26a69a',
        wickDownColor: props?.createChart?.downColor || '#ef5350',
      })
      candlestickSeriesRef.current.priceScale().applyOptions({
        scaleMargins: chartScaleMargins,
      })
    }

    if (timeLineRef.current) {
      timeLineRef.current.priceScale().applyOptions({
        scaleMargins: chartScaleMargins,
      })
    }

    if (smaLineRef.current) {
      smaLineRef.current.forEach(item => {
        item.priceScale().applyOptions({
          scaleMargins: chartScaleMargins,
        })
      })
    }

    if (difRef.current) {
      difRef.current.priceScale().applyOptions({
        scaleMargins: macdScaleMargins,
      })
    }

    if (deaRef.current) {
      deaRef.current.priceScale().applyOptions({
        scaleMargins: macdScaleMargins,
      })
    }

    if (macdVolumeSeriesRef.current) {
      macdVolumeSeriesRef.current.priceScale().applyOptions({
        scaleMargins: macdScaleMargins,
      })
    }

    if (volumeSeriesRef.current) {
      volumeSeriesRef.current.priceScale().applyOptions({
        scaleMargins: volScaleMargins,
      })
    }

    if (bollRef.current) {
      bollRef.current.mid.priceScale().applyOptions({
        scaleMargins: chartScaleMargins,
      })
      bollRef.current.upper.priceScale().applyOptions({
        scaleMargins: chartScaleMargins,
      })
      bollRef.current.lower.priceScale().applyOptions({
        scaleMargins: chartScaleMargins,
      })
    }

    if (kdjRef.current) {
      kdjRef.current.k.priceScale().applyOptions({
        scaleMargins: kdjScaleMargins,
      })
      kdjRef.current.d.priceScale().applyOptions({
        scaleMargins: kdjScaleMargins,
      })
      kdjRef.current.j.priceScale().applyOptions({
        scaleMargins: kdjScaleMargins,
      })
    }

    if (rsiRef.current) {
      rsiRef.current.forEach(item => {
        item.priceScale().applyOptions({
          scaleMargins: rsiScaleMargins,
        })
      })
    }

    if (wrRef.current) {
      wrRef.current.forEach(item => {
        item.priceScale().applyOptions({
          scaleMargins: wrScaleMargins,
        })
      })
    }
  }, [heightChange, subIndicator, colors])

  const mainKList = [
    {
      name: timeLocaleLanguageMap[props.locale]['时间'],
      value: 'time',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['开'],
      value: 'open',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['高'],
      value: 'high',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['低'],
      value: 'low',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['收'],
      value: 'close',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['涨跌幅'],
      value: 'chg',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['振幅'],
      value: 'amp',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['量'],
      value: 'volume',
    },
    {
      name: timeLocaleLanguageMap[props.locale]['额'],
      value: 'quoteVolume',
    },
  ]

  const getHeight = scaleMargins => {
    if (containerRef.current?.clientHeight) {
      return (containerRef.current.clientHeight - 26) * scaleMargins - 18
    }
  }

  const getChg = (mainK, priceOffset) => {
    let symbol = ''
    if (mainK?.close - mainK?.open > 0) {
      symbol = '+'
    }
    const val = (Number(mainK?.close) - Number(mainK?.open)).toFixed(priceOffset)
    return `${symbol}${val}(${symbol}${mainK?.chg})`
  }

  const hoverSum = [mainK?.buy, mainK?.sell, mainK?.overBuy, mainK?.overSell, mainK?.priceSpread].filter(item => {
    return item
  })?.length
  return (
    <div className="chart" id="chart" ref={containerRef}>
      {tradeStatusOverList?.length ? (
        tradeStatusOverList[0].loading ? (
          <div
            className="chart-max-or-min-price"
            style={{
              top:
                tradeStatusOverList[0].sideInd === tradeDirection.call ||
                tradeStatusOverList[0].sideInd === tradeDirection.overCall
                  ? tradeStatusOverList[0].y - 35
                  : tradeStatusOverList[0].y,
              left: tradeStatusOverList[0].x - 17 || 0,
              color: props.createChart.textColor01,
            }}
          >
            <div style={{ width: '34px', height: '34px', background: props.createChart.bgColor }}>
              {optionAnimation.loading}
            </div>
          </div>
        ) : (
          <div
            className="chart-max-or-min-price"
            style={{
              top:
                tradeStatusOverList[0].sideInd === tradeDirection.call ||
                tradeStatusOverList[0].sideInd === tradeDirection.overCall
                  ? tradeStatusOverList[0].y - 35
                  : tradeStatusOverList[0].y,
              left: tradeStatusOverList[0].x - 17 || 0,
              color: props.createChart.textColor01,
            }}
          >
            {tradeStatusOverList[0].realizedProfit > 0 ? (
              // eslint-disable-next-line jsx-a11y/media-has-caption
              <audio
                src="https://bitcastle-frontend-static.s3.ap-southeast-1.amazonaws.com/audio/win.mp3"
                autoPlay
              ></audio>
            ) : (
              // eslint-disable-next-line jsx-a11y/media-has-caption
              <audio
                src="https://bitcastle-frontend-static.s3.ap-southeast-1.amazonaws.com/audio/lose.mp3"
                autoPlay
              ></audio>
            )}

            {tradeStatusOverList[0].realizedProfit > 0 ? null : (
              <div style={{ width: '34px', height: '34px', background: props.createChart.bgColor }}>
                {optionAnimation[tradeStatusOverList[0].sideInd]}
              </div>
            )}
          </div>
        )
      ) : null}
      {!tradeStatusOverList[0]?.loading && tradeStatusOverList[0]?.realizedProfit > 0 ? (
        <div
          className="chart-max-or-min-price"
          style={{
            top: (containerRef.current?.clientHeight || tradeStatusOverList[0].y) / 2 - 90,
            left: (containerRef.current?.clientWidth || tradeStatusOverList[0].x) / 2 - 140,
            color: props.createChart.textColor01,
            width: '280px',
            height: '180px',
          }}
        >
          {optionAnimation.win}
        </div>
      ) : null}
      {/* {audioStatus === TernaryOptionTradeStatus.success ? (
          <audio
            src="https://bitcastle-frontend-static.s3.ap-southeast-1.amazonaws.com/audio/win.mp3"
            autoPlay
            onEnded={() => {
              console.log('播放结束1')
              setAudioStatus(TernaryOptionTradeStatus.wait)
            }}
          ></audio>
        ) : null}
        {audioStatus === TernaryOptionTradeStatus.fail ? (
          <audio
            src="https://bitcastle-frontend-static.s3.ap-southeast-1.amazonaws.com/audio/lose.mp3"
            autoPlay
            onEnded={() => {
              console.log('播放结束2')
              setAudioStatus(TernaryOptionTradeStatus.wait)
            }}
          ></audio>
        ) : null} */}
      {props.curTime.unit === 's' ? (
        <div
          className="chart-max-or-min-price"
          style={{
            top: curBuyAndSellPoint.max.y - 34 - 12 || 0,
            left: curBuyAndSellPoint.max.x || 0,
            color: props.createChart.textColor01,
          }}
        >
          {tradeRestSecond ? (
            countDownComponent(TernaryOptionTradeDirectionEnum.call)
          ) : (
            <div
              onClick={e => {
                e.stopPropagation()
                optionBuyCallback()
              }}
            >
              {optionActiveTab === 'normal' ? optionIcon.up : optionIcon.overUp}
            </div>
          )}
        </div>
      ) : null}

      {props.curTime.unit === 's' ? (
        <div
          className="chart-max-or-min-price"
          style={{
            top: curBuyAndSellPoint.max.y + 12 || 0,
            left: curBuyAndSellPoint.max.x || 0,
            color: props.createChart.textColor01,
          }}
        >
          {tradeRestSecond ? (
            countDownComponent(TernaryOptionTradeDirectionEnum.put)
          ) : (
            <div
              onClick={e => {
                e.stopPropagation()
                optionSellCallback()
              }}
            >
              {optionActiveTab === 'normal' ? optionIcon.down : optionIcon.overDown}
            </div>
          )}
        </div>
      ) : null}
      {/* {curMaxAndMinPoint.max.value !== curMaxAndMinPoint.min.value ? (
        <div
          className="chart-max-or-min-price"
          style={{
            top: curMaxAndMinPoint.max.y - 20 || 0,
            left: curMaxAndMinPoint.max.x || 0,
            transform: curMaxAndMinPoint.max.x < 80 ? 'scale(0.83)' : 'translateX(-90%) scale(0.83)',
            color: props.createChart.textColor01,
          }}
        >
          {curMaxAndMinPoint.max.x < 80
            ? [
                <div key={2} className="bg-text_color_01" style={{ width: '16px', height: '1px' }}></div>,
                <span className="ml-1" key={1}>
                  {curMaxAndMinPoint.max.value}
                </span>,
              ]
            : [
                <span key={1}>{curMaxAndMinPoint.max.value}</span>,
                <div key={2} className="bg-text_color_01 ml-1" style={{ width: '16px', height: '1px' }}></div>,
              ]}
        </div>
      ) : null} */}
      {/* <div
        className="chart-max-or-min-price"
        style={{
          top: curMaxAndMinPoint.min.y || 0,
          left: curMaxAndMinPoint.min.x || 0,
          transform: curMaxAndMinPoint.min.x < 80 ? 'scale(0.83)' : 'translateX(-90%) scale(0.83)',
          color: props.createChart.textColor01,
        }}
      >
        {curMaxAndMinPoint.min.x < 80
          ? [
              <div key={2} className="bg-text_color_01" style={{ width: '16px', height: '1px' }}></div>,
              <span className="ml-1" key={1}>
                {curMaxAndMinPoint.min.value}
              </span>,
            ]
          : [
              <span key={1}>{curMaxAndMinPoint.min.value}</span>,
              <div key={2} className="bg-text_color_01 ml-1" style={{ width: '16px', height: '1px' }}></div>,
            ]}
      </div> */}
      <div className="ma">
        {mainIndicator.ma.select ? (
          <div className="text-text_color_03 k-line-ind-wrap common-text">
            {mainIndicator.ma.cur.map((item, index) => {
              if (item.select) {
                return (
                  <span key={item.strip} className="ma-child">
                    {`MA(${item.strip})`}
                    <span className="common-ml-5" style={{ color: item.color }}>
                      {maIndicator?.[index]?.toFixed(priceOffset)}
                    </span>
                  </span>
                )
              }
              return null
            })}
          </div>
        ) : null}

        {mainIndicator.boll.select ? (
          <div className="k-line-ind-wrap text-text_color_03 common-text">
            <span className="ma-child">
              {`BOLL(${mainIndicator.boll.cur.mid}, ${mainIndicator.boll.cur.std}):`}
              <span className="common-ml-5">UP</span>
              <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[0].color }}>
                {bollK.upper}
              </span>
              <span className="common-ml-5">MB</span>
              <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[1].color }}>
                {bollK.mid}
              </span>
              <span className="common-ml-5">DN</span>
              <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[2].color }}>
                {bollK.lower}
              </span>
            </span>
          </div>
        ) : null}
      </div>
      {subIndicator.vol?.select ? (
        <div
          className="common-sub-ind text-text_color_03"
          style={{
            // top: `${(macdScaleMargins.top - 0.05) * 100}%`,
            /** chart 下移了0.5，这里递减 */
            // top: `calc(${(volScaleMargins.top - 0.1) * 100}% - 10px)`,
            top: getHeight(volScaleMargins.top),
          }}
        >
          <span>
            <span>Vol({coinInfo.baseSymbolName})</span>
            <span
              className="common-ml-5"
              style={{ color: volume.dir === 'rise' ? props.createChart.upColor : props.createChart.downColor }}
            >
              {volume.vol}
            </span>
          </span>
          <span className="common-ml-5">
            <span>Vol({coinInfo.quoteSymbolName})</span>
            <span
              style={{ color: volume.dir === 'rise' ? props.createChart.upColor : props.createChart.downColor }}
              className="common-ml-5"
            >
              {volume.quoteVolume}
            </span>
          </span>
        </div>
      ) : null}

      {subIndicator.macd.select ? (
        <div
          className="common-sub-ind common-text text-text_color_03"
          style={{
            top: getHeight(macdScaleMargins.top),
          }}
        >
          <span>{`MACD(${subIndicator.macd.cur.fast}, ${subIndicator.macd.cur.slow}, ${subIndicator.macd.cur.signal})`}</span>
          <span className="common-ml-5" style={{ color: '#9660c4' }}>
            {Number(subK?.dea).toFixed(priceOffset)}
          </span>
          <span className="common-ml-5" style={{ color: '#84aad5' }}>
            {Number(subK?.dif).toFixed(priceOffset)}
          </span>
          <span
            className="common-ml-5"
            style={{ color: Number(subK?.macd) > 0 ? props.createChart.upColor : props.createChart.downColor }}
          >
            {Number(subK?.macd).toFixed(priceOffset)}
          </span>
        </div>
      ) : null}

      {subIndicator.kdj.select ? (
        <div
          style={{
            top: getHeight(kdjScaleMargins.top),
          }}
          className="common-sub-ind  common-text text-text_color_03"
        >
          <span className="ma-child">
            {`KDJ(${subIndicator.kdj.cur.k}, ${subIndicator.kdj.cur.d}, ${subIndicator.kdj.cur.j}):`}
            <span className="common-ml-5">K</span>
            <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[0].color }}>
              {kdjK?.k}
            </span>
            <span className="common-ml-5">D</span>
            <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[1].color }}>
              {kdjK?.d}
            </span>
            <span className="common-ml-5">J</span>
            <span className="common-ml-5" style={{ color: mainIndicator.ma.cur[2].color }}>
              {kdjK?.j}
            </span>
          </span>
        </div>
      ) : null}

      {subIndicator.rsi.select ? (
        <div
          style={{
            top: getHeight(rsiScaleMargins.top),
          }}
          className="common-sub-ind common-text text-text_color_03"
        >
          {subIndicator.rsi.cur.map((item, index) => {
            if (item.select) {
              return (
                <span key={index} className="ma-child">
                  {`RSI(${item.value})`}
                  <span className="common-ml-5" style={{ color: item.color }}>
                    {rsiK?.[Object.keys(rsiK)[index]]}
                  </span>
                </span>
              )
            }
            return null
          })}
        </div>
      ) : null}

      {subIndicator.wr.select ? (
        <div
          style={{
            top: getHeight(wrScaleMargins.top),
          }}
          className="common-sub-ind common-text text-text_color_03"
        >
          {subIndicator.wr.cur.map((item, index) => {
            if (item.select) {
              return (
                <span key={index} className="ma-child">
                  {`Wm %R(${item.value})`}
                  <span className="common-ml-5" style={{ color: item.color }}>
                    {wrK?.[index]}
                  </span>
                </span>
              )
            }
            return null
          })}
        </div>
      ) : null}
      <div
        className="k-data"
        style={{
          background: props.createChart.cardBgColor03,
          display: chartCrossHair.show ? 'block' : 'none',
          top: chartCrossHair.y,
          left: chartCrossHair.x,
          height:
            hoverSum === 4
              ? '206px'
              : hoverSum === 3
              ? '194px'
              : hoverSum === 2
              ? '218px'
              : hoverSum === 1
              ? '199px'
              : '180px',
        }}
      >
        {mainKList.map((item, index) => {
          return (
            <div
              key={item.value}
              style={{
                height: '11px',
                marginTop: index === 0 ? 0 : hoverSum > 2 ? '4px' : '8px',
              }}
              className="flex justify-between items-center gap-2 text-text_color_02"
            >
              <span>{item.name}</span>
              <span
                className={classNames({
                  'text-buy_up_color': item.value === 'chg' && mainK?.isUp,
                  'text-text_color_01': item.value !== 'chg',
                  'text-sell_down_color': item.value === 'chg' && !mainK?.isUp,
                })}
              >
                {item.value === 'volume' || item.value === 'quoteVolume'
                  ? numFormat(mainK?.[item.value], 2)
                  : item.value === 'chg'
                  ? getChg(mainK, priceOffset)
                  : item.value === 'open' || item.value === 'high' || item.value === 'low' || item.value === 'close'
                  ? Number(mainK?.[item.value])?.toFixed(priceOffset)
                  : mainK?.[item.value]}
              </span>
            </div>
          )
        })}
        {mainK?.buy ? (
          <div
            style={{ height: '11px', marginTop: hoverSum > 2 ? '4px' : '8px' }}
            className="flex justify-between items-center gap-2 text-text_color_02"
          >
            <span>{timeLocaleLanguageMap[props.locale]['买涨']}</span>
            <span className={classNames('text-text_color_01')}>{mainK?.buy}</span>
          </div>
        ) : null}
        {mainK?.sell ? (
          <div
            style={{ height: '11px', marginTop: hoverSum > 2 ? '4px' : '8px' }}
            className="flex justify-between items-center gap-2 text-text_color_02"
          >
            <span>{timeLocaleLanguageMap[props.locale]['买跌']}</span>
            <span className={classNames('text-text_color_01')}>{mainK?.sell}</span>
          </div>
        ) : null}

        {mainK?.overBuy ? (
          <div
            style={{ height: '11px', marginTop: hoverSum > 2 ? '4px' : '8px' }}
            className="flex justify-between items-center gap-2 text-text_color_02"
          >
            <span>{timeLocaleLanguageMap[props.locale]['买超涨']}</span>
            <span className={classNames('text-text_color_01')}>{mainK?.overBuy}</span>
          </div>
        ) : null}

        {mainK?.overSell ? (
          <div
            style={{ height: '11px', marginTop: hoverSum > 2 ? '4px' : '8px' }}
            className="flex justify-between items-center gap-2 text-text_color_02"
          >
            <span>{timeLocaleLanguageMap[props.locale]['买超跌']}</span>
            <span className={classNames('text-text_color_01')}>{mainK?.overSell}</span>
          </div>
        ) : null}

        {mainK?.priceSpread ? (
          <div
            style={{ height: '11px', marginTop: hoverSum > 2 ? '4px' : '8px' }}
            className="flex justify-between items-center gap-2 text-text_color_02"
          >
            <span>{timeLocaleLanguageMap[props.locale]['价差']}</span>
            <span className={classNames('text-text_color_01')}>{mainK?.priceSpread}</span>
          </div>
        ) : null}
      </div>
      {/* <div className='buy-sell-pop'>
        {
          mainKList.map((item) => {
            return (
              <div className='pop-row' key={item.value}>
                <span>{item.name}</span>
                <span>{mainK?.[item.value]}</span>
                </div>
            )
          })
        }
      </div> */}
    </div>
  )
}

export default forwardRef(KLineChart)
